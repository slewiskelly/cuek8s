// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/autoscaler/vertical-pod-autoscaler/pkg/apis/autoscaling.k8s.io/v1

// Package v1 contains definitions of Vertical Pod Autoscaler related objects.
package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	autoscaling "k8s.io/api/autoscaling/v1"
	"k8s.io/api/core/v1"
)

// VerticalPodAutoscalerList is a list of VerticalPodAutoscaler objects.
#VerticalPodAutoscalerList: {
	metav1.#TypeMeta

	// metadata is the standard list metadata.
	// +optional
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// items is the list of vertical pod autoscaler objects.
	items: [...#VerticalPodAutoscaler] @go(Items,[]VerticalPodAutoscaler) @protobuf(2,bytes,rep)
}

// VerticalPodAutoscaler is the configuration for a vertical pod
// autoscaler, which automatically manages pod resources based on historical and
// real time resource utilization.
#VerticalPodAutoscaler: {
	metav1.#TypeMeta

	// Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the behavior of the autoscaler.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status.
	spec: #VerticalPodAutoscalerSpec @go(Spec) @protobuf(2,bytes)

	// Current information about the autoscaler.
	// +optional
	status?: #VerticalPodAutoscalerStatus @go(Status) @protobuf(3,bytes,opt)
}

// VerticalPodAutoscalerSpec is the specification of the behavior of the autoscaler.
#VerticalPodAutoscalerSpec: {
	// TargetRef points to the controller managing the set of pods for the
	// autoscaler to control - e.g. Deployment, StatefulSet. VerticalPodAutoscaler
	// can be targeted at controller implementing scale subresource (the pod set is
	// retrieved from the controller's ScaleStatus) or some well known controllers
	// (e.g. for DaemonSet the pod set is read from the controller's spec).
	// If VerticalPodAutoscaler cannot use specified target it will report
	// ConfigUnsupported condition.
	// Note that VerticalPodAutoscaler does not require full implementation
	// of scale subresource - it will not use it to modify the replica count.
	// The only thing retrieved is a label selector matching pods grouped by
	// the target resource.
	targetRef?: null | autoscaling.#CrossVersionObjectReference @go(TargetRef,*autoscaling.CrossVersionObjectReference) @protobuf(1,bytes)

	// Describes the rules on how changes are applied to the pods.
	// If not specified, all fields in the `PodUpdatePolicy` are set to their
	// default values.
	// +optional
	updatePolicy?: null | #PodUpdatePolicy @go(UpdatePolicy,*PodUpdatePolicy) @protobuf(2,bytes,opt)

	// Controls how the autoscaler computes recommended resources.
	// The resource policy may be used to set constraints on the recommendations
	// for individual containers. If not specified, the autoscaler computes recommended
	// resources for all containers in the pod, without additional constraints.
	// +optional
	resourcePolicy?: null | #PodResourcePolicy @go(ResourcePolicy,*PodResourcePolicy) @protobuf(3,bytes,opt)
}

// PodUpdatePolicy describes the rules on how changes are applied to the pods.
#PodUpdatePolicy: {
	// Controls when autoscaler applies changes to the pod resources.
	// The default is 'Auto'.
	// +optional
	updateMode?: null | #UpdateMode @go(UpdateMode,*UpdateMode) @protobuf(1,bytes,opt)
}

// UpdateMode controls when autoscaler applies changes to the pod resoures.
#UpdateMode: string // #enumUpdateMode

#enumUpdateMode:
	#UpdateModeOff |
	#UpdateModeInitial |
	#UpdateModeRecreate |
	#UpdateModeAuto

// UpdateModeOff means that autoscaler never changes Pod resources.
// The recommender still sets the recommended resources in the
// VerticalPodAutoscaler object. This can be used for a "dry run".
#UpdateModeOff: #UpdateMode & "Off"

// UpdateModeInitial means that autoscaler only assigns resources on pod
// creation and does not change them during the lifetime of the pod.
#UpdateModeInitial: #UpdateMode & "Initial"

// UpdateModeRecreate means that autoscaler assigns resources on pod
// creation and additionally can update them during the lifetime of the
// pod by deleting and recreating the pod.
#UpdateModeRecreate: #UpdateMode & "Recreate"

// UpdateModeAuto means that autoscaler assigns resources on pod creation
// and additionally can update them during the lifetime of the pod,
// using any available update method. Currently this is equivalent to
// Recreate, which is the only available update method.
#UpdateModeAuto: #UpdateMode & "Auto"

// PodResourcePolicy controls how autoscaler computes the recommended resources
// for containers belonging to the pod. There can be at most one entry for every
// named container and optionally a single wildcard entry with `containerName` = '*',
// which handles all containers that don't have individual policies.
#PodResourcePolicy: {
	// Per-container resource policies.
	// +optional
	// +patchMergeKey=containerName
	// +patchStrategy=merge
	containerPolicies?: [...#ContainerResourcePolicy] @go(ContainerPolicies,[]ContainerResourcePolicy) @protobuf(1,bytes,rep)
}

// ContainerResourcePolicy controls how autoscaler computes the recommended
// resources for a specific container.
#ContainerResourcePolicy: {
	// Name of the container or DefaultContainerResourcePolicy, in which
	// case the policy is used by the containers that don't have their own
	// policy specified.
	containerName?: string @go(ContainerName) @protobuf(1,bytes,opt)

	// Whether autoscaler is enabled for the container. The default is "Auto".
	// +optional
	mode?: null | #ContainerScalingMode @go(Mode,*ContainerScalingMode) @protobuf(2,bytes,opt)

	// Specifies the minimal amount of resources that will be recommended
	// for the container. The default is no minimum.
	// +optional
	minAllowed?: v1.#ResourceList @go(MinAllowed) @protobuf(3,bytes,rep,casttype=ResourceList,castkey=ResourceName)

	// Specifies the maximum amount of resources that will be recommended
	// for the container. The default is no maximum.
	// +optional
	maxAllowed?: v1.#ResourceList @go(MaxAllowed) @protobuf(4,bytes,rep,casttype=ResourceList,castkey=ResourceName)

	// Specifies the type of recommendations that will be computed
	// (and possibly applied) by VPA.
	// If not specified, the default of [ResourceCPU, ResourceMemory] will be used.
	controlledResources?: null | [...v1.#ResourceName] @go(ControlledResources,*[]v1.ResourceName) @protobuf(5,bytes,rep)

	// Specifies which resource values should be controlled.
	// The default is "RequestsAndLimits".
	// +optional
	controlledValues?: null | #ContainerControlledValues @go(ControlledValues,*ContainerControlledValues) @protobuf(6,bytes,rep)
}

// DefaultContainerResourcePolicy can be passed as
// ContainerResourcePolicy.ContainerName to specify the default policy.
#DefaultContainerResourcePolicy: "*"

// ContainerScalingMode controls whether autoscaler is enabled for a specific
// container.
#ContainerScalingMode: string // #enumContainerScalingMode

#enumContainerScalingMode:
	#ContainerScalingModeAuto |
	#ContainerScalingModeOff

// ContainerScalingModeAuto means autoscaling is enabled for a container.
#ContainerScalingModeAuto: #ContainerScalingMode & "Auto"

// ContainerScalingModeOff means autoscaling is disabled for a container.
#ContainerScalingModeOff: #ContainerScalingMode & "Off"

// ContainerControlledValues controls which resource value should be autoscaled.
#ContainerControlledValues: string // #enumContainerControlledValues

#enumContainerControlledValues:
	#ContainerControlledValuesRequestsAndLimits |
	#ContainerControlledValuesRequestsOnly

// ContainerControlledValuesRequestsAndLimits means resource request and limits
// are scaled automatically. The limit is scaled proportionally to the request.
#ContainerControlledValuesRequestsAndLimits: #ContainerControlledValues & "RequestsAndLimits"

// ContainerControlledValuesRequestsOnly means only requested resource is autoscaled.
#ContainerControlledValuesRequestsOnly: #ContainerControlledValues & "RequestsOnly"

// VerticalPodAutoscalerStatus describes the runtime state of the autoscaler.
#VerticalPodAutoscalerStatus: {
	// The most recently computed amount of resources recommended by the
	// autoscaler for the controlled pods.
	// +optional
	recommendation?: null | #RecommendedPodResources @go(Recommendation,*RecommendedPodResources) @protobuf(1,bytes,opt)

	// Conditions is the set of conditions required for this autoscaler to scale its target,
	// and indicates whether or not those conditions are met.
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	conditions?: [...#VerticalPodAutoscalerCondition] @go(Conditions,[]VerticalPodAutoscalerCondition) @protobuf(2,bytes,rep)
}

// RecommendedPodResources is the recommendation of resources computed by
// autoscaler. It contains a recommendation for each container in the pod
// (except for those with `ContainerScalingMode` set to 'Off').
#RecommendedPodResources: {
	// Resources recommended by the autoscaler for each container.
	// +optional
	containerRecommendations?: [...#RecommendedContainerResources] @go(ContainerRecommendations,[]RecommendedContainerResources) @protobuf(1,bytes,rep)
}

// RecommendedContainerResources is the recommendation of resources computed by
// autoscaler for a specific container. Respects the container resource policy
// if present in the spec. In particular the recommendation is not produced for
// containers with `ContainerScalingMode` set to 'Off'.
#RecommendedContainerResources: {
	// Name of the container.
	containerName?: string @go(ContainerName) @protobuf(1,bytes,opt)

	// Recommended amount of resources. Observes ContainerResourcePolicy.
	target: v1.#ResourceList @go(Target) @protobuf(2,bytes,rep,casttype=ResourceList,castkey=ResourceName)

	// Minimum recommended amount of resources. Observes ContainerResourcePolicy.
	// This amount is not guaranteed to be sufficient for the application to operate in a stable way, however
	// running with less resources is likely to have significant impact on performance/availability.
	// +optional
	lowerBound?: v1.#ResourceList @go(LowerBound) @protobuf(3,bytes,rep,casttype=ResourceList,castkey=ResourceName)

	// Maximum recommended amount of resources. Observes ContainerResourcePolicy.
	// Any resources allocated beyond this value are likely wasted. This value may be larger than the maximum
	// amount of application is actually capable of consuming.
	// +optional
	upperBound?: v1.#ResourceList @go(UpperBound) @protobuf(4,bytes,rep,casttype=ResourceList,castkey=ResourceName)

	// The most recent recommended resources target computed by the autoscaler
	// for the controlled pods, based only on actual resource usage, not taking
	// into account the ContainerResourcePolicy.
	// May differ from the Recommendation if the actual resource usage causes
	// the target to violate the ContainerResourcePolicy (lower than MinAllowed
	// or higher that MaxAllowed).
	// Used only as status indication, will not affect actual resource assignment.
	// +optional
	uncappedTarget?: v1.#ResourceList @go(UncappedTarget) @protobuf(5,bytes,opt)
}

// VerticalPodAutoscalerConditionType are the valid conditions of
// a VerticalPodAutoscaler.
#VerticalPodAutoscalerConditionType: string

// VerticalPodAutoscalerCondition describes the state of
// a VerticalPodAutoscaler at a certain point.
#VerticalPodAutoscalerCondition: {
	// type describes the current condition
	type: #VerticalPodAutoscalerConditionType @go(Type) @protobuf(1,bytes)

	// status is the status of the condition (True, False, Unknown)
	status: v1.#ConditionStatus @go(Status) @protobuf(2,bytes)

	// lastTransitionTime is the last time the condition transitioned from
	// one status to another
	// +optional
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime) @protobuf(3,bytes,opt)

	// reason is the reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason) @protobuf(4,bytes,opt)

	// message is a human-readable explanation containing details about
	// the transition
	// +optional
	message?: string @go(Message) @protobuf(5,bytes,opt)
}

// VerticalPodAutoscalerCheckpoint is the checkpoint of the internal state of VPA that
// is used for recovery after recommender's restart.
#VerticalPodAutoscalerCheckpoint: {
	metav1.#TypeMeta

	// Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the checkpoint.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status.
	// +optional
	spec?: #VerticalPodAutoscalerCheckpointSpec @go(Spec) @protobuf(2,bytes,opt)

	// Data of the checkpoint.
	// +optional
	status?: #VerticalPodAutoscalerCheckpointStatus @go(Status) @protobuf(3,bytes,opt)
}

// VerticalPodAutoscalerCheckpointList is a list of VerticalPodAutoscalerCheckpoint objects.
#VerticalPodAutoscalerCheckpointList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#VerticalPodAutoscalerCheckpoint] @go(Items,[]VerticalPodAutoscalerCheckpoint)
}

// VerticalPodAutoscalerCheckpointSpec is the specification of the checkpoint object.
#VerticalPodAutoscalerCheckpointSpec: {
	// Name of the VPA object that stored VerticalPodAutoscalerCheckpoint object.
	vpaObjectName?: string @go(VPAObjectName) @protobuf(1,bytes,opt)

	// Name of the checkpointed container.
	containerName?: string @go(ContainerName) @protobuf(2,bytes,opt)
}

// VerticalPodAutoscalerCheckpointStatus contains data of the checkpoint.
#VerticalPodAutoscalerCheckpointStatus: {
	// The time when the status was last refreshed.
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime) @protobuf(1,bytes,opt)

	// Version of the format of the stored data.
	version?: string @go(Version) @protobuf(2,bytes,opt)

	// Checkpoint of histogram for consumption of CPU.
	cpuHistogram?: #HistogramCheckpoint @go(CPUHistogram) @protobuf(3,bytes,rep,name=cpuHistograms)

	// Checkpoint of histogram for consumption of memory.
	memoryHistogram?: #HistogramCheckpoint @go(MemoryHistogram) @protobuf(4,bytes,rep)

	// Timestamp of the fist sample from the histograms.
	firstSampleStart?: metav1.#Time @go(FirstSampleStart) @protobuf(5,bytes,opt)

	// Timestamp of the last sample from the histograms.
	lastSampleStart?: metav1.#Time @go(LastSampleStart) @protobuf(6,bytes,opt)

	// Total number of samples in the histograms.
	totalSamplesCount?: int @go(TotalSamplesCount) @protobuf(7,bytes,opt)
}

// HistogramCheckpoint contains data needed to reconstruct the histogram.
#HistogramCheckpoint: {
	// Reference timestamp for samples collected within this histogram.
	referenceTimestamp?: metav1.#Time @go(ReferenceTimestamp) @protobuf(1,bytes,opt)

	// Sum of samples to be used as denominator for weights from BucketWeights.
	totalWeight?: float64 @go(TotalWeight) @protobuf(3,bytes,opt)
}
